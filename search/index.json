[{"content":"近来尝试了很多可部署开源阅读器项目，但大多体验都不太理想，Calibre-Web​将阅读记录储存在了浏览器缓存中，注定了它对我来说只是个半成品。Reader​网页版，是个不错的选择，但是奈何鄙人不会 Kotlin ，再一个就是本身项目对二次开发好像也不太友好，固放弃。\n转念一想，自己开发一个 Android App 不就好了，多的不说，直接开始搞俩哈。\n开始 WebView 是不可能 WebView的，这辈子都不可能WebView的。真男人就要干 Native！\n开发环境：\nSDK ：Android 12L (S) API 32\nIDE ：IntelliJ IDEA\n测试设备：RedMi K30 S U\n首先在 IDEA 中新建项目，选择 Android，没有安装相关 SDK 的朋友，需要先下载安装相关的开发工具包，这里建议 IDEA 设置中开启科学上网。\n​​\n下载完成后新建一个 Android 项目，选择Phone and Tablet​中的Basic Activity​，我这边选择使用 Java 语言进行开发，项目名叫啥都行\n​​\n这时候 gradle 会先 sync 一遍，如果你所用的测试平台没有相应的 SDK 就会构建失败，这时候到设置中的Android SDK​中下载相应的软件包，然后通过项目结构​更新以下项目 SDK ，刷新 Gradle，大功告成。\n打包运行 可以看到我们当前选择的默认模板已经给我们搭建好了基本的框架，也就是说现在项目可以直接打包运行了。接下来先确保手机处于可以调试的状态，先是打开手机的开发者模式，在开发者选项中打开USB调试​以及通过USB安装​这两项，小米系手机如果到这一步还是不行的话，可以尝试关闭开发者选项中的MIUI优化​。\n点击右上角运行​\n​​\n顺利运行~\n","date":"2022-06-27T11:34:54-07:00","image":"https://philomel.github.io/post/androidnative-%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/cover_hu13f0c7aeb98c811b71c95a9090fe6fa8_56183_120x120_fill_q75_box_smart1.jpg","permalink":"https://philomel.github.io/post/androidnative-%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"【Android】Native 应用入门-环境搭建"},{"content":"先短暂的解决一下阅读需求，写一个简单的 Java 推送 SiYuan 程序，实现起来也非常简单。\n事先准备好 SiYuan 的 Token​\nMaven 依赖\n\u0026lt;!-- 电子书解析器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.positiondev.epublib\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;epublib-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${epublib.version}\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- HTML解析 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;!-- jsoup HTML parser library @ https://jsoup.org/ --\u0026gt; \u0026lt;groupId\u0026gt;org.jsoup\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsoup\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.11.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- HTML 转 Markdown --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.kotcrab.remark\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;remark\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 如果启动时候日志依赖冲突，就把 epublib​中的日志模块剔除掉\n在自己的随便一个 Spring 项目中添加一个接口\npublic void post2Siyuan(String epubPath) { File file = new File(epubPath); InputStream in = null; try { //从输入流当中读取epub格式文件 EpubReader reader = new EpubReader(); in = new FileInputStream(file); Book book = reader.readEpub(in); //获取到书本的头部信息 Metadata metadata = book.getMetadata(); //获取到书本的全部资源 Resources resources = book.getResources(); //获取到书本的内容资源(正文) List\u0026lt;Resource\u0026gt; contents = book.getContents(); String bookName = metadata.getFirstTitle(); String author = metadata.getAuthors().get(0).toString().replace(\u0026#34;,\u0026#34;,\u0026#34;\u0026#34;); StringBuilder chapterContent = new StringBuilder(); String markdown; //contents.remove(0); for (Resource content : contents) { chapterContent.append(new String(content.getData(), StandardCharsets.UTF_8)); } markdown = new Remark().convertFragment(chapterContent.toString()); Map\u0026lt;String, Object\u0026gt; siyuanSendData = new HashMap\u0026lt;\u0026gt;(); siyuanSendData.put(\u0026#34;notebook\u0026#34;, \u0026#34;笔记本ID\u0026#34;); siyuanSendData.put(\u0026#34;path\u0026#34;, \u0026#34;/\u0026#34;+ bookName + \u0026#34; - \u0026#34; + author); siyuanSendData.put(\u0026#34;markdown\u0026#34;, markdown); String siyuanResp = HttpRequest.post(SIYUAN_URL + SIYUAN_API_CREATE_DOC) .contentType(\u0026#34;application/json\u0026#34;, \u0026#34;UTF-8\u0026#34;) .authorization(SIYUAN_TOKEN) .send(JSON.toJSONString(siyuanSendData)) .body(); System.out.println(siyuanResp); } catch (Exception e) { e.printStackTrace(); } finally { //一定要关闭资源 try { if (in != null) { in.close(); } } catch (IOException e) { e.printStackTrace(); } } } 大功告成 ","date":"2022-06-13T08:50:54-07:00","image":"https://philomel.github.io/post/javasiyuan-%E5%AE%9E%E7%8E%B0-epub-%E9%98%85%E8%AF%BB/cover_hub4afae136500df36392ab993cb552397_422517_120x120_fill_q75_box_smart1.jpg","permalink":"https://philomel.github.io/post/javasiyuan-%E5%AE%9E%E7%8E%B0-epub-%E9%98%85%E8%AF%BB/","title":"【Java】SiYuan 实现 Epub 阅读"},{"content":"前排提示，本文使用方法搭建出来的静态博客需要科学上网才能访问。\n开始 我们先来看看 Telegraph 是个啥子东东，这是官网的介绍\nTelegraph 并不强调内容管理方这一概念，真正做到了「人人都是媒体」。通过 Telegraph 发布的文章，理论上来说不会存在删除的危险，并且由于会产生一个独立的网址链接，所以我们发布的内容可以完全公开在万维网上。我们可以随时随地、匿名发布任何消息，一切不会受到任何监管。「匿名、不受监管」，这应该就是 Telegraph 所强调的自由。\n简单来说，只要进入 https://telegra.ph 并编辑本章，点击 Publish ，你的文章就会被匿名地公开到万维网，并且长期保存。 Telegraph 支持上传图片、MarkDown格式。这些操作并不需要你注册 Telegram 账户。\n值得注意的是，一旦浏览器清空缓存后，文章将不可再编辑。\n接口发布 博文 发布文章的方式一共有两种，一种就是上面提到的直接在网站中编辑内容。另一种就是通过接口的方式发布。\n接口文档：https://telegra.ph/api\n创建文章接口\n参数名 类型 是否必须 access_token String Required title String Required author_name String Optional author_url String Optional content Array of Node Required return_content Boolean, default = false Optional 其中 access_token 通过 createAccount 接口注册获得。\nauthor_url 可以指向任何外链。\ncontent 中的 Node 为类似 HTML 的结构实体组成，如下：\npublic class HtmlNode { private String tag; private Map\u0026lt;String,String\u0026gt; attrs; private List\u0026lt;Object\u0026gt; children; } 构造 Map ，发送 Http 请求\npublic String publicBlog(List\u0026lt;String\u0026gt; imgSrc, String topic) { List\u0026lt;HtmlNode\u0026gt; nodes = new ArrayList\u0026lt;\u0026gt;(); HtmlNode imgNode = new HtmlNode(); Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String s : imgSrc) { Map\u0026lt;String, String\u0026gt; attrsMap = new HashMap\u0026lt;\u0026gt;(); imgNode.setTag(\u0026#34;img\u0026#34;); attrsMap.put(\u0026#34;src\u0026#34;, s); imgNode.setAttrs(attrsMap); if (s.contains(\u0026#34;.jpg\u0026#34;)) nodes.add(imgNode); } HtmlNode topicNode = new HtmlNode(); topicNode.setTag(\u0026#34;h3\u0026#34;); List\u0026lt;String\u0026gt; topicChild = new ArrayList\u0026lt;\u0026gt;(); topicChild.add(topic); topicNode.setChildren(Arrays.asList(topicChild.toArray())); nodes.add(topicNode); map.put(\u0026#34;access_token\u0026#34;, \u0026#34;1sad2910nc90cn13caw7d2e211dcsa212a\u0026#34;); map.put(\u0026#34;title\u0026#34;, \u0026#34;PH Second Blog Page\u0026#34;); map.put(\u0026#34;author_name\u0026#34;, \u0026#34;Philomel\u0026#34;); map.put(\u0026#34;author_url\u0026#34;, \u0026#34;https://t.me/xxx\u0026#34;); map.put(\u0026#34;content\u0026#34;, JSON.toJSONString(nodes)); map.put(\u0026#34;return_content\u0026#34;, false); String resp = HttpRequest.post(\u0026#34;https://api.telegra.ph/createPage\u0026#34;) .useProxy(PROXY_IP, PROXY_PORT) .form(map) .body(); return JSON.parseObject(resp).getJSONObject(\u0026#34;result\u0026#34;).get(\u0026#34;url\u0026#34;).toString(); } 接下来访问回调参数中的 url 即可。\n图床 图床接口使用：https://telegra.ph/upload\n直接构造一个带有 file 的 Http请求 即可：\npublic String uploadTgraph(File file,Proxy proxy) { return HttpUtil.createPost(\u0026#34;https://telegra.ph/upload\u0026#34;) .setProxy(proxy) .form(\u0026#34;file\u0026#34;, file) .execute() .body(); ｝ 从回调参数获取 url 。\n文章示例 ","date":"2022-05-30T15:36:54-07:00","image":"https://philomel.github.io/post/telegraph%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/cover_hu4231234965c402f5b071dc3bf8bd12ee_1400271_120x120_fill_q75_box_smart1.jpg","permalink":"https://philomel.github.io/post/telegraph%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/","title":"【Telegraph】搭建静态博客/图床"},{"content":"上篇文章已经实现了如何设置 Webhook 并实现 复读 功能，但是仅仅是这样显然是不够的，为了让 Bot 功能更强大，程序更具有健壮性，我们可以将 Bot 与 SpringBoot 整合。\n基于 Bot 接口是 HTTP 协议的，所以不管是什么语言，整合起来都是没有什么困难的。比如说 Python ，Telegram 官方甚至提供了SDK。\n依赖引入 首先是 springboot-starter \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.0\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!--SpringBoot--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Http 使用 kevinsawicki 的包 \u0026lt;!--http调用--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.kevinsawicki\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;http-request\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; JSON工具包也不能落下 \u0026lt;!--JSON转换--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.75\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Webhook 设置 setWebhook Use this method to specify a URL and receive incoming updates via an outgoing webhook. Whenever there is an update for the bot, we will send an HTTPS POST request to the specified URL, containing a JSON-serialized Update. In case of an unsuccessful request, we will give up after a reasonable amount of attempts. Returns True on success.\n根据 Telegram 要求，要使用 Webhook 功能，消息接受服务器必须具有 HTTPS 协议的 URL 。\n一般来说，购入一个境外域名，并通过 frp 穿透到境外服务器，再购入 SSL 证书即可解决上面这个问题。\n接口设计 那么到这一步，基本懂 Spring 的都知道如何进行接下来的开发了。\n首先，设计一个接口，通过 Map\u0026lt;String, Object\u0026gt; 接受所有 Webhook 的 update 消息（json格式）。\n@PostMapping(\u0026#34;/webhook\u0026#34;) public void webhook(@RequestBody Map\u0026lt;String, Object\u0026gt; webhookData) { JSONObject json = JSON.parseObject(JSON.toJSONString(webhookData)); System.out.println(json); } 尝试发送一条文字消息。\n查看控制台打印，可以看到类似这样的 json 结构\n{ \u0026#34;message\u0026#34;: { \u0026#34;chat\u0026#34;: { \u0026#34;id\u0026#34;: 111, \u0026#34;type\u0026#34;: \u0026#34;private\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;xx\u0026#34;, \u0026#34;last_name\u0026#34;: \u0026#34;x\u0026#34;, \u0026#34;first_name\u0026#34;: \u0026#34;x\u0026#34; }, \u0026#34;date\u0026#34;: 1660264576, \u0026#34;from\u0026#34;: { \u0026#34;id\u0026#34;: 12, \u0026#34;is_bot\u0026#34;: false, \u0026#34;username\u0026#34;: \u0026#34;xx\u0026#34;, \u0026#34;last_name\u0026#34;: \u0026#34;x\u0026#34;, \u0026#34;first_name\u0026#34;: \u0026#34;x\u0026#34;, \u0026#34;language_code\u0026#34;: \u0026#34;zh-hans\u0026#34; }, \u0026#34;text\u0026#34;: \u0026#34;/emoji\u0026#34;, \u0026#34;entities\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;bot_command\u0026#34;, \u0026#34;length\u0026#34;: 6, \u0026#34;offset\u0026#34;: 0 } ], \u0026#34;message_id\u0026#34;: 1 }, \u0026#34;update_id\u0026#34;: 13 } 其中 text 就是发送的消息内容\n接下来依据 json 结构编写实体类，这里可以使用 GsonFormatPlus 工具自动生成\n返回消息 sendMessage Use this method to send text messages. On success, the sent Message is returned.\n向 sendMessage 接口发送 POST 请求，并携带 chat_id、text 这两个必要参数，即可向指定账户发送消息（其中 chat_id 从上述 json 中获取）。\n先写一个 Http 客户端\npublic static String doPost(String api, Map\u0026lt;String, Object\u0026gt; sendData) { return HttpRequest.post(BOT_URL + api) .useProxy(PROXY_IP, PROXY_PORT) .trustAllCerts().trustAllHosts() .connectTimeout(60000) .readTimeout(60000) .form(sendData) .body(); } 构造 sendData 并调用 dopost(sendData) 方法\nMap\u0026lt;String, Object\u0026gt; sendData = new HashMap\u0026lt;\u0026gt;(); sendData.put(\u0026#34;text\u0026#34;, \u0026#34;收到了哦~\u0026#34;); sendData.put(\u0026#34;chat_id\u0026#34;, chatId); chatHandler.doPost(sendData); 执行 Http 请求后，我们可以接收到回调数据\n{ \u0026#34;ok\u0026#34;: true, \u0026#34;result\u0026#34;: { \u0026#34;chat\u0026#34;: { \u0026#34;id\u0026#34;: 123, \u0026#34;type\u0026#34;: \u0026#34;private\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;xx\u0026#34;, \u0026#34;last_name\u0026#34;: \u0026#34;x\u0026#34;, \u0026#34;first_name\u0026#34;: \u0026#34;x\u0026#34; }, \u0026#34;date\u0026#34;: 1660264578, \u0026#34;from\u0026#34;: { \u0026#34;id\u0026#34;: 123, \u0026#34;is_bot\u0026#34;: true, \u0026#34;username\u0026#34;: \u0026#34;xxBot\u0026#34;, \u0026#34;first_name\u0026#34;: \u0026#34;xxBot\u0026#34; }, \u0026#34;photo\u0026#34;: [ { \u0026#34;width\u0026#34;: 46, \u0026#34;height\u0026#34;: 51, \u0026#34;file_id\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;file_size\u0026#34;: 1731, \u0026#34;file_unique_id\u0026#34;: \u0026#34;123\u0026#34; } ], \u0026#34;caption\u0026#34;: \u0026#34;随机图片~\u0026#34;, \u0026#34;message_id\u0026#34;: 12, \u0026#34;reply_markup\u0026#34;: { \u0026#34;inline_keyboard\u0026#34;: [ [ { \u0026#34;url\u0026#34;: \u0026#34;http://blog.philomel.top/\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;个人网站\u0026#34; } ] ] } } } 至此，我们已经初步了解了如何使用 SpringBoot 对 Bot 进行开发，其他的接口也相对来说没有什么太大的难度。\n但是使用过一段时候后会发现，Bot 限制还是比较多的，上传、下载都非常不方便。接下来的文章我会介绍 Telethon 这款客户端接口，该接口基本与客户端权限一致，用代码的方式直接控制我们的账户。\n","date":"2022-05-10T10:37:54-07:00","image":"https://philomel.github.io/post/telegarmbot%E4%B8%8Espringboot%E6%95%B4%E5%90%88/cover.svg","permalink":"https://philomel.github.io/post/telegarmbot%E4%B8%8Espringboot%E6%95%B4%E5%90%88/","title":"【TelegarmBot】与SpringBoot整合"},{"content":"众所周知，TG提供着一个近乎无线容量的个人云空间，同时TG拥有信息、资源聚合的特性，以及功能完备的机器人接口、对开发者友好的开放平台。 鉴于以上，目前我的想法是做一个，可以索引公共信息并且聚合信息同时提供私有云上传/下载服务功能的自动化机器人。 该 @Bot 教程后续通过 Java 平台持续开发。\n一共是三个功能点。\n解析信息 索引信息 私有云上传/下载 前期工作 创建机器人（@BotFather /newbot）\n从 @BotFather 中取得 token\n发送 GET 请求，获取 bot 接收到的信息\nhttps://api.telegram.org/bot(token)/getUpdates 设置Webhook（当bot接收到消息后自动发送POST请求到指定url）\n先尝试用gmail部署钩子脚本应用\nhttps://api.telegram.org/bot(token)/setwebhook?url=callbackur\n谷歌Apps Script管理\n基础脚本代码\nfunction doPost(e){ var estringa = JSON.parse(e.postData.contents); var payload = identificar(estringa); var data = { \u0026#34;method\u0026#34;: \u0026#34;post\u0026#34;, \u0026#34;payload\u0026#34;: payload } UrlFetchApp.fetch(\u0026#34;https://api.telegram.org/bot(token)/\u0026#34;, data); } function identificar(e){ if (e.message.text){ var mensaje = { \u0026#34;method\u0026#34;: \u0026#34;sendMessage\u0026#34;, \u0026#34;chat_id\u0026#34;: e.message.chat.id.toString(), \u0026#34;text\u0026#34;: e.message.text, } } else if (e.message.sticker){ var mensaje = { \u0026#34;method\u0026#34;: \u0026#34;sendSticker\u0026#34;, \u0026#34;chat_id\u0026#34;: e.message.chat.id.toString(), \u0026#34;sticker\u0026#34;: e.message.sticker.file_id } } else if (e.message.photo){ var array = e.message.photo; var text = array[1]; var mensaje = { \u0026#34;method\u0026#34;: \u0026#34;sendPhoto\u0026#34;, \u0026#34;chat_id\u0026#34;: e.message.chat.id.toString(), \u0026#34;photo\u0026#34;: text.file_id } } else { var mensaje = { \u0026#34;method\u0026#34;: \u0026#34;sendMessage\u0026#34;, \u0026#34;chat_id\u0026#34;: e.message.chat.id.toString(), \u0026#34;text\u0026#34;: \u0026#34;Try other stuff\u0026#34; } } return mensaje } 通过上面的流程，一个基础的复读机 bot 就算是做好了，后续将会继续深入 bot 的其他接口进行定制化开发。\n","date":"2022-04-21T08:36:54-07:00","image":"https://philomel.github.io/post/telegrambot%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84webhook%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94/cover_huc9c2e614ff49174ccdb62b49149808e8_88265_120x120_fill_q75_box_smart1.jpg","permalink":"https://philomel.github.io/post/telegrambot%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84webhook%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94/","title":"【TelegramBot】从0开始的Webhook自动应答"}]